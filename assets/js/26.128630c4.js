(window.webpackJsonp=window.webpackJsonp||[]).push([[26],{342:function(e,t,s){"use strict";s.r(t);var a=s(28),i=Object(a.a)({},function(){var e=this,t=e.$createElement,s=e._self._c||t;return s("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[s("h1",{attrs:{id:"quality-plan"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#quality-plan","aria-hidden":"true"}},[e._v("#")]),e._v(" Quality Plan")]),e._v(" "),s("p",[e._v("This is the high-level for the COOP registries application. This platform will later be used to host all entity types. Current MVP is limited to Annual Report, Change of Address and Change of Director filings.")]),e._v(" "),s("h3",{attrs:{id:"philosophy"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#philosophy","aria-hidden":"true"}},[e._v("#")]),e._v(" Philosophy")]),e._v(" "),s("p",[e._v("Testing aims to catch unexpected behaviour before code is moved into production. Effort-wise it is 'cheaper' to catch issues as early as possible. A developer should be able to write the first tests based off of the Acceptance Criteria in the ticket. If the Acceptance Criteria are unclear, then clarify what you need prior to starting the task. From there, the normal testing pyramid applies - cover as much as possible with unit and integration tests, then add manual and browser-level end-to-end tests.")]),e._v(" "),s("p",[e._v("The highest value (read: most tests) should be placed on securing the legacy database, and on the quality of the user experience.")]),e._v(" "),s("p",[e._v("Testing and quality go beyond writing tests. As much as possible, design code that can be tested easily. For example, the main UI controls should have coherently named IDs for easy browser automation. APIs should be designed to return extra details about downstream outcomes to ease testing. Layering in tracing as early as possible also helps with detecting issues as quickly as possible after code is deployed into production.")]),e._v(" "),s("p",[e._v("Having an extensive test suite is important, but it is also important that all resources know how to run the tests. Ideally, the deployment pipelines would run all tests that are available for each component of the application. Pre-commit testing is being planned and reviewed so that as many tests as possible can be run locally prior to moving into the dev environment. Pending link to section describing local dev setup for testing")]),e._v(" "),s("p",[e._v("Manual testing will be completed by both devs and QA resource(s). Repetitive manual tests, or tests that require long set-up/complex test data should considered candidates for future automation.")]),e._v(" "),s("h3",{attrs:{id:"roles"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#roles","aria-hidden":"true"}},[e._v("#")]),e._v(" Roles")]),e._v(" "),s("p",[e._v("Developers will write unit and integration tests for each pull request they work on. They will also put in place test fixtures and other test apparatus needed to run tests at all layers.\nQA resource(s) will expand existing test suites as needed with a focus on end-to-end tests. QA will work to define when code is ready to be released into production.")]),e._v(" "),s("h3",{attrs:{id:"pre-release-checklist"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#pre-release-checklist","aria-hidden":"true"}},[e._v("#")]),e._v(" Pre-release checklist")]),e._v(" "),s("p",[e._v("This is just draft for now but things like:")]),e._v(" "),s("ul",[s("li",[e._v("All test pipeline test suites green")]),e._v(" "),s("li",[e._v("Our users have been notified")]),e._v(" "),s("li",[e._v("Other good things...")])])])},[],!1,null,null,null);t.default=i.exports}}]);